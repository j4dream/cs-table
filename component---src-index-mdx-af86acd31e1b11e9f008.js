(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"7A3R":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return l})),n.d(t,"default",(function(){return o}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var a=n("/FXl"),r=n("TjRS");n("CpJs"),n("aD51");function b(){return(b=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/index.mdx"}});var c={_frontmatter:l},i=r.a;function o(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(i,b({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"虚拟化表格"},"虚拟化表格"),Object(a.b)("h2",{id:"虚拟化-virtualized"},"虚拟化 Virtualized"),Object(a.b)("p",null,"这里涉及到一个常见前端问题，在JS中操作渲染大量 DOM（长列表问题），会导致浏览器严重卡顿，甚至出现假死状态。",Object(a.b)("br",{parentName:"p"}),"\n","通常解决这种情况有以下三种办法："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("ol",{parentName:"li"},Object(a.b)("li",{parentName:"ol"},"分页。"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("ol",b({parentName:"li"},{start:2}),Object(a.b)("li",{parentName:"ol"},"滚动加载，逐步加载 DOM (但有个缺点，如果加载多了改动布局的时候仍然会卡顿)。"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("ol",b({parentName:"li"},{start:3}),Object(a.b)("li",{parentName:"ol"},"虚拟化，仅渲染视区显示数据。")))),Object(a.b)("p",null,"这里主要实现的是第三点，也就是前端遇到一些无法使用分页处理的场景。  "),Object(a.b)("p",null,"先用 Antd Table 简单对比一下，拖动表头改变列的宽度，体验一下两者区别："),Object(a.b)("a",{href:"https://codesandbox.io/s/antd-resize-5u469",target:"_blank"},"Antd Table 未虚拟化"),"--VS--",Object(a.b)("a",{href:"https://codesandbox.io/s/antd-resize-5u469",target:"_blank"},"Antd Table 虚拟化"),Object(a.b)("h2",{id:"现有组件现状"},"现有组件现状"),Object(a.b)("p",null,"因为开源的组件大部分都缺少我想要的功能。",Object(a.b)("br",{parentName:"p"}),"\n","其实主要是支持虚拟化，同时支持用户动态调整行列大小，交换行列顺序，同时保留用户这些改动。"),Object(a.b)("p",null,"在此之前都尝试过以下组件:"),Object(a.b)("p",null,"Ant design table(rc-table)，在 3.X 时未支持，拖动排序(表头)，拖动缩放表格宽度，未支持虚拟化，\n这导致数据量比较多的时候, 页面渲染慢。\n虽然 Ant design table 在 4.X 之后，可以使用 react-window 渲染列表，但并不支持嵌套行表头，嵌套拖动排序。"),Object(a.b)("p",null,"Element react table，数据量大的时候也存在性能问题，而且未提供虚拟化渲染。\n在数据更新的时候导致页面 reflow，卡顿几秒，同时功能上也未满足需求。"),Object(a.b)("p",null,"另一个 React Virtualized，也玩了一会，在测试大量数据后组件依然流畅，但功能并不满足，具体表现:\n不支持行嵌套表头，不可伸缩，不支持行列排序。"),Object(a.b)("h2",{id:"安装使用"},"安装使用"),Object(a.b)("p",null,"npm 安装，未依赖其他库"),Object(a.b)("pre",null,Object(a.b)("code",b({parentName:"pre"},{className:"language-javascript"}),"npm i virtualized-sc-table --save\n")),Object(a.b)("p",null,"使用 (详情使用请参考后面篇章)"),Object(a.b)("pre",null,Object(a.b)("code",b({parentName:"pre"},{className:"language-javascript"}),"import { CTable, STable } from 'virtualized-sc-table';\n\n// 一般表格\n<CTable\n  header={header}\n  data={data}\n  // renderCell={(record, prop) => record[prop]}\n  // renderHeader={(header, prop) => header[prop]}\n/>\n\n// 聚合统计表格\n<STable\n  colHeader={[]}\n  rowHeader={[]}\n  data={header}\n/>\n\n")),Object(a.b)("h2",{id:"待续"},"待续"),Object(a.b)("ol",{start:0},Object(a.b)("li",{parentName:"ol"},"更好支持 Typescript，更完善的 Test Case，CI/CD；"),Object(a.b)("li",{parentName:"ol"},"保存 header 状态（resize，sort 之后状态）；"),Object(a.b)("li",{parentName:"ol"},"少量数据更好的展示方式；"),Object(a.b)("li",{parentName:"ol"},"暗黑模式；")))}void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/index.mdx"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-index-mdx-af86acd31e1b11e9f008.js.map